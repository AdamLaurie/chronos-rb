; CHRONOS-Rb Frequency Counter PIO Program
;
; Counts rising edges of the 10MHz reference signal continuously.
; CPU reads count on each PPS pulse.

.program freq_counter

    mov y, null             ; Initialize count to 0

.wrap_target
count_loop:
    wait 0 pin 0            ; Wait for low
    wait 1 pin 0            ; Wait for rising edge
    jmp y-- count_loop      ; Decrement Y (counts down from 0)
.wrap

% c-sdk {
#include "hardware/clocks.h"
#include "hardware/gpio.h"

static inline void freq_counter_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_config c = freq_counter_program_get_default_config(offset);

    // Configure input pin
    sm_config_set_in_pins(&c, pin);

    // Initialize pin for PIO
    pio_gpio_init(pio, pin);
    gpio_set_dir(pin, GPIO_IN);

    // Run at system clock
    sm_config_set_clkdiv(&c, 1.0);

    // Load configuration
    pio_sm_init(pio, sm, offset, &c);
}

// Read current count and reset - call from PPS handler
static inline uint32_t freq_counter_read_and_reset(PIO pio, uint sm) {
    // Stop the state machine
    pio_sm_set_enabled(pio, sm, false);

    // Execute: mov isr, ~y (opcode: 0xa0c9)
    // This moves inverted Y to ISR
    pio_sm_exec(pio, sm, 0xa0c9);

    // Execute: push (opcode: 0x8020)
    pio_sm_exec(pio, sm, 0x8020);

    // Read the count from FIFO
    uint32_t count = pio_sm_get(pio, sm);

    // Execute: mov y, null (opcode: 0xa043)
    // This resets Y to 0
    pio_sm_exec(pio, sm, 0xa043);

    // Restart the state machine
    pio_sm_set_enabled(pio, sm, true);

    return count;
}
%}
