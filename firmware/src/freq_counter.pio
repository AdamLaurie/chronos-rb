; CHRONOS-Rb Frequency Counter PIO Program
;
; Hardware-only PPS validation against 10MHz reference.
; Counts 10MHz edges between PPS pulses - should be exactly 10,000,000.
;
; Pin mapping:
;   - IN pin 0: 10MHz input (directly from comparator)
;   - JMP pin: PPS input (directly from PPS source)
;
; Pins do NOT need to be consecutive - uses separate pin configs.
;
; Operation:
;   1. Wait for PPS rising edge (using jmp pin polling)
;   2. Count 10MHz edges until next PPS rising edge
;   3. Push count to FIFO
;   4. Repeat
;
; CPU just reads counts from FIFO - no timing-critical involvement.
; Expected count: exactly 10,000,000 if signals are phase-locked.

.program freq_counter

.wrap_target
    ; Wait for PPS to be low (so we can detect rising edge)
wait_pps_low:
    jmp pin wait_pps_low    ; Loop while PPS is high

    ; Wait for PPS rising edge
wait_pps_rise:
    jmp pin pps_rose        ; Exit when PPS goes high
    jmp wait_pps_rise       ; Keep polling

pps_rose:
    ; PPS just went high - start counting
    mov x, ~null            ; X = 0xFFFFFFFF (count down from max)

    ; Wait for PPS to go low again (end of pulse)
wait_pps_low2:
    jmp pin wait_pps_low2   ; Loop while PPS is still high

count_loop:
    ; Check if next PPS pulse arrived (gate end)
    jmp pin gate_done       ; If PPS high, measurement complete

    ; Wait for 10MHz rising edge and count it
    wait 0 pin 0            ; Wait for 10MHz low
    wait 1 pin 0            ; Wait for 10MHz high
    jmp x-- count_loop      ; Decrement X and loop (always jumps for <4B edges)

gate_done:
    ; Push count to FIFO for CPU to read
    mov isr, ~x             ; Invert X to get positive count
    push noblock

    ; Signal CPU using IRQ flag 1 (flag 0 used by pps_generator)
    irq nowait 1
.wrap

; PPS edge capture with 10MHz counter
; Counts 10MHz continuously, captures count at PPS rising edge
; Used for both FE PPS and GPS PPS - one instance each
;
; Pin mapping:
;   - IN pin 0: 10MHz input
;   - JMP pin: PPS input (FE or GPS)
;
; Pushes captured count to FIFO on each PPS rising edge
; Count is in 10MHz ticks (100ns resolution)
;
; IMPORTANT: Counts continuously even while PPS is high.
; Uses Y register as state flag: Y=0 means waiting for rising edge,
; Y=non-zero means already captured this pulse.
.program pps_capture

    set y, 0                    ; Initialize: waiting for rising edge

.wrap_target
main_loop:
    ; Count one 10MHz edge
    wait 0 pin 0                ; Wait for 10MHz low
    wait 1 pin 0                ; Wait for 10MHz high
    jmp x-- check_pps           ; Count it, then check PPS state

check_pps:
    jmp pin pps_is_high         ; If PPS high, handle it
    ; PPS is low - reset state flag and continue counting
    set y, 0
    jmp main_loop

pps_is_high:
    ; PPS is high - check if we need to capture (rising edge)
    jmp !y do_capture           ; If Y=0, this is a rising edge
    jmp main_loop               ; Y!=0, already captured, keep counting

do_capture:
    mov isr, ~x                 ; Capture inverted X (positive count)
    push noblock                ; Push to FIFO
    set y, 1                    ; Mark that we captured this pulse
    jmp main_loop
.wrap

% c-sdk {
#include "hardware/clocks.h"
#include "hardware/gpio.h"

static inline void pps_capture_program_init(PIO pio, uint sm, uint offset,
                                             uint mhz_pin, uint pps_pin) {
    pio_sm_config c = pps_capture_program_get_default_config(offset);

    // IN pin for 10MHz input (used by wait instructions)
    sm_config_set_in_pins(&c, mhz_pin);

    // JMP pin for PPS input (used by jmp pin instructions)
    sm_config_set_jmp_pin(&c, pps_pin);

    // Run at system clock for maximum speed
    sm_config_set_clkdiv(&c, 1.0);

    // Load configuration
    pio_sm_init(pio, sm, offset, &c);

    // Initialize X to 0 (will count down, wrapping around)
    pio_sm_exec(pio, sm, pio_encode_set(pio_x, 0));
}

// Read captured count from FIFO (non-blocking)
// Returns true if a capture was available
static inline bool pps_capture_read(PIO pio, uint sm, uint32_t *count) {
    if (pio_sm_is_rx_fifo_empty(pio, sm)) {
        return false;
    }
    *count = pio_sm_get(pio, sm);
    return true;
}

static inline void freq_counter_program_init(PIO pio, uint sm, uint offset,
                                              uint mhz_pin, uint pps_pin) {
    pio_sm_config c = freq_counter_program_get_default_config(offset);

    // IN pin for 10MHz input (used by wait instructions)
    sm_config_set_in_pins(&c, mhz_pin);

    // JMP pin for PPS input (used by jmp pin instructions)
    sm_config_set_jmp_pin(&c, pps_pin);

    // For input pins, PIOs can read GPIO state regardless of function select.
    // Don't call pio_gpio_init or gpio_init - they change function select
    // which can conflict with other modules using the same pins.
    // Just ensure pins are configured as inputs by the modules that own them.

    // Run at system clock for maximum speed
    sm_config_set_clkdiv(&c, 1.0);

    // Load configuration
    pio_sm_init(pio, sm, offset, &c);
}

// Read frequency count from FIFO (non-blocking)
// Returns true if a measurement was available
static inline bool freq_counter_read(PIO pio, uint sm, uint32_t *count) {
    if (pio_sm_is_rx_fifo_empty(pio, sm)) {
        return false;
    }
    *count = pio_sm_get(pio, sm);
    return true;
}
%}
